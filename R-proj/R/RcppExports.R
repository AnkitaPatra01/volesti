# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

solve_undetermined_system_lu <- function(Ar, br) {
    .Call(`_volesti_solve_undetermined_system_lu`, Ar, br)
}

#' Internal rcpp function for the rounding of a convex polytope
#'
#' @param P A convex polytope (H- or V-representation or zonotope).
#' @param method Optional. The method to use for rounding, a) \code{'min_ellipsoid'} for the method based on mimimmum volume enclosing ellipsoid of a uniform sample from P, b) \code{'max_ellipsoid'} for the method based on maximum volume enclosed ellipsoid in P, (c) \code{'svd'} for the method based on svd decomposition. The default method is \code{'min_ellipsoid'} for all the representations.
#' @param seed Optional. A fixed seed for the number generator.
#'
#' @keywords internal
#'
#' @return A numerical matrix that describes the rounded polytope, a numerical matrix of the inverse linear transofmation that is applied on the input polytope, the numerical vector the the input polytope is shifted and the determinant of the matrix of the linear transformation that is applied on the input polytope.
NULL

mmcs_phase <- function(center, radius, parameters) {
    .Call(`_volesti_mmcs_phase`, center, radius, parameters)
}

#' Gelman-Rubin and Brooks-Gelman Potential Scale Reduction Factor (PSRF) for each marginal
#'
#' @param samples A matrix that contans column-wise the sampled points from a geometric random walk.
#' @param method A string to reauest diagnostic: (i) \code{'normal'} for psrf of Gelman-Rubin and (ii) \code{'interval'} for psrf of Brooks-Gelman.
#'
#' @references \cite{Gelman, A. and Rubin, D. B.,
#' \dQuote{Inference from iterative simulation using multiple sequences,} \emph{Statistical Science,} 1992.}
#'
#' @references \cite{Brooks, S. and Gelman, A.,
#' \dQuote{General Methods for Monitoring Convergence of Iterative Simulations,} \emph{Journal of Computational and Graphical Statistics,} 1998.}
#'
#' @return A vector that contains the values of PSRF for each coordinate
#'
#' @export
psrf_univariate <- function(samples, method = NULL) {
    .Call(`_volesti_psrf_univariate`, samples, method)
}

#' Sample uniformly, normally distributed, or logconcave distributed points from a convex Polytope (H-polytope, V-polytope, zonotope or intersection of two V-polytopes).
#'
#' @param P A convex polytope. It is an object from class (a) Hpolytope or (b) Vpolytope or (c) Zonotope or (d) VpolytopeIntersection.
#' @param n The number of points that the function is going to sample from the convex polytope.
#' @param random_walk Optional. A list that declares the random walk and some related parameters as follows:
#' \itemize{
#' \item{\code{walk} }{ A string to declare the random walk: i) \code{'CDHR'} for Coordinate Directions Hit-and-Run, ii) \code{'RDHR'} for Random Directions Hit-and-Run, iii) \code{'BaW'} for Ball Walk, iv) \code{'BiW'} for Billiard walk, v) \code{'dikin'} for dikin walk, vi) \code{'vaidya'} for vaidya walk, vii) \code{'john'} for john walk, viii) \code{'BCDHR'} boundary sampling by keeping the extreme points of CDHR or ix) \code{'BRDHR'} boundary sampling by keeping the extreme points of RDHR x) \code{'HMC'} for Hamiltonian Monte Carlo (logconcave) xi) \code{'ULD'} for Underdamped Langevin Dynamics using the Randomized Midpoint Method. The default walk is \code{'aBiW'} for the uniform distribution or \code{'CDHR'} for the Gaussian distribution and H-polytopes and \code{'BiW'} or \code{'RDHR'} for the same distributions and V-polytopes and zonotopes.}
#' \item{\code{walk_length} }{ The number of the steps per generated point for the random walk. The default value is \eqn{1}.}
#' \item{\code{nburns} }{ The number of points to burn before start sampling. The default value is \eqn{1}.}
#' \item{\code{starting_point} }{ A \eqn{d}-dimensional numerical vector that declares a starting point in the interior of the polytope for the random walk. The default choice is the center of the ball as that one computed by the function \code{inner_ball()}.}
#' \item{\code{BaW_rad} }{ The radius for the ball walk.}
#' \item{\code{L} }{ The maximum length of the billiard trajectory or the radius for the step of dikin, vaidya or john walk.}
#' \item{\code{solver}} {Specify ODE solver for logconcave sampling. Options are i) leapfrog, ii) euler iii) runge-kutta iv) richardson}
#' \item{\code{step_size} {Optionally chosen step size for logconcave sampling. Defaults to a theoretical value if not provided.}}
#' }
#' @param distribution Optional. A list that declares the target density and some related parameters as follows:
#' \itemize{
#' \item{\code{density} }{ A string: (a) \code{'uniform'} for the uniform distribution or b) \code{'gaussian'} for the multidimensional spherical distribution. The default target distribution is uniform. c) Logconcave with form proportional to exp(-f(x)) where f(x) is L-smooth and m-strongly-convex. }
#' \item{\code{variance} }{ The variance of the multidimensional spherical gaussian. The default value is 1.}
#' \item{\code{mode} }{ A \eqn{d}-dimensional numerical vector that declares the mode of the Gaussian distribution. The default choice is the center of the as that one computed by the function \code{inner_ball()}.}
#' \item{\code{L_}} { Smoothness constant (for logconcave). }
#' \item{\code{m}} { Strong-convexity constant (for logconcave). }
#' \item{\code{negative_logprob}} { Negative log-probability (for logconcave). }
#' \item{\code{negative_logprob_gradient}} { Negative log-probability gradient (for logconcave). }
#' }
#' @param seed Optional. A fixed seed for the number generator.
#'
#' @references \cite{Robert L. Smith,
#' \dQuote{Efficient Monte Carlo Procedures for Generating Points Uniformly Distributed Over Bounded Regions,} \emph{Operations Research,} 1984.},
#'
#' @references \cite{B.T. Polyak, E.N. Gryazina,
#' \dQuote{Billiard walk - a new sampling algorithm for control and optimization,} \emph{IFAC Proceedings Volumes,} 2014.},
#'
#' @references \cite{Y. Chen, R. Dwivedi, M. J. Wainwright and B. Yu,
#' \dQuote{Fast MCMC Sampling Algorithms on Polytopes,} \emph{Journal of Machine Learning Research,} 2018.}
#'
#' @references \cite{Lee, Yin Tat, Ruoqi Shen, and Kevin Tian,
#' \dQuote{"Logsmooth Gradient Concentration and Tighter Runtimes for Metropolized Hamiltonian Monte Carlo,"} \emph{arXiv preprint arXiv:2002.04121}, 2020.}
#'
#' @references \cite{Shen, Ruoqi, and Yin Tat Lee,
#' \dQuote{"The randomized midpoint method for log-concave sampling.",} \emph{Advances in Neural Information Processing Systems}, 2019.}
#'
#' @return A \eqn{d\times n} matrix that contains, column-wise, the sampled points from the convex polytope P.
#' @examples
#' # uniform distribution from the 3d unit cube in H-representation using ball walk
#' P = gen_cube(3, 'H')
#' points = sample_points(P, n = 100, random_walk = list("walk" = "BaW", "walk_length" = 5))
#'
#' # gaussian distribution from the 2d unit simplex in H-representation with variance = 2
#' A = matrix(c(-1,0,0,-1,1,1), ncol=2, nrow=3, byrow=TRUE)
#' b = c(0,0,1)
#' P = Hpolytope$new(A,b)
#' points = sample_points(P, n = 100, distribution = list("density" = "gaussian", "variance" = 2))
#'
#' # uniform points from the boundary of a 2-dimensional random H-polytope
#' P = gen_rand_hpoly(2,20)
#' points = sample_points(P, n = 100, random_walk = list("walk" = "BRDHR"))
#'
#' # For sampling from logconcave densities see the examples directory
#'
#' @export
sample_points <- function(P, n, random_walk = NULL, distribution = NULL, seed = NULL) {
    .Call(`_volesti_sample_points`, P, n, random_walk, distribution, seed)
}

